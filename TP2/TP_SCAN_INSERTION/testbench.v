// MAX TB Test Protocol File, generated by MAX TB Version M-2016.12
// Tue Oct  2 17:12:02 2018
// Module under test: CORE
// Generated from original STIL file : "/tp/xph3sei/xph3sei201/TP_TEST/TP2/TP_SCAN_INSERTION/patterns_alarm_clock.v"
// STIL file version: "1.0"
// Enhanced Runtime Version: use <sim_exec> +tmax_help for available runtime options
// Simulation mode: default parallel simulation

`define TDATA_FILE "/tp/xph3sei/xph3sei201/TP_TEST/TP2/TP_SCAN_INSERTION/testbench.dat"
`timescale 1ns/1ns

// OPCODE DEFINITION
`define EndPat 0
`define IncPat 1
`define SetPat 2
`define WFTStmt 3
`define ConditionStmt 4
`define VectorStmt 5
`define FixedStmt 6
`define GenLoopStmt 7
`define EndGenLoopStmt 8
`define GenTestSetupStmt 9
`define EndGenTestSetupStmt 10
`define SetForceSI 11
`define test_setupStmt 12
`define load_unloadStmt 13
`define allclock_launchStmt 14
`define allclock_captureStmt 15
`define multiclock_captureStmt 16
`define allclock_launch_captureStmt 17

// SIGS DEFINITION
`define SET_TIME 0
`define ALARM 1
`define HOURS 2
`define MINUTES 3
`define TOGGLE 4
`define CLOCK 5
`define RESETN 6
`define TEST_MODE 7
`define TEST_SE 8
`define TEST_SI 9
`define SPEAKER 10
`define \HR[13]  11
`define \HR[12]  12
`define \HR[11]  13
`define \HR[10]  14
`define \HR[9]  15
`define \HR[8]  16
`define \HR[7]  17
`define \HR[6]  18
`define \HR[5]  19
`define \HR[4]  20
`define \HR[3]  21
`define \HR[2]  22
`define \HR[1]  23
`define \HR[0]  24
`define \MIN[13]  25
`define \MIN[12]  26
`define \MIN[11]  27
`define \MIN[10]  28
`define \MIN[9]  29
`define \MIN[8]  30
`define \MIN[7]  31
`define \MIN[6]  32
`define \MIN[5]  33
`define \MIN[4]  34
`define \MIN[3]  35
`define \MIN[2]  36
`define \MIN[1]  37
`define \MIN[0]  38
`define AM_PM 39
`define _pi 40
`define all_inputs 41
`define _po 42
`define _si 43
`define all_outputs 44
`define _clk 45
`define _so 46

// WFTS DEFINITION
`define _multiclock_capture_WFT_ 0
`define _default_WFT_ 1
`define _allclock_launch_WFT_ 2
`define _allclock_capture_WFT_ 3
`define _allclock_launch_capture_WFT_ 4
`define MAX_PART 0

`define MAXTB_HEADER " MAX TB Version M-2016.12\n Test Protocol File generated from original file \"/tp/xph3sei/xph3sei201/TP_TEST/TP2/TP_SCAN_INSERTION/patterns_alarm_clock.v\"\n STIL file version: 1.0"
`define MAXTB_H_S "#############################################################################"


module /* maxtb */ CORE_test ();
   parameter NSTMTS = 18; // number of all stmts
   parameter DFSHIFTS = 0; // (default) number of serial shifts in parallel scan mode
   parameter NAMELENGTH = 200; // max length of names reported in fails
   parameter FILELENGTH = 1024; // max length for file names 
   parameter MAXCHLEN = 40, NCHAINS = 1; // MAXCHLEN for serial
   parameter NINPUTS = 10, NOUTPUTS = 30, CUM_WIDTH=124;
   parameter NSIS = 1, NSOUTS = 1;
   parameter WFT_IDS = 5, SIG_IDS = 47, SIG_IDS_W = 6, MAX_WIDTH = 30, MAX_SIGW = 1;
   parameter PARSERINC = 40; 
   parameter SYNC_LATENCY = 3; 
   parameter PRTIME = 0.000000; 
   integer xtb_sim_mode; // simulation modes: xtb_sim_mode=0 -> serial, xtb_sim_mode=1 -> parallel (default);
   integer nbfails, abit, cbit;
   integer prev_error; // flag for tracking displayed error banner
   integer loads;        // number of load_unloads for current pattern
   integer prev_pat;     // previous pattern number;
   integer rep_pat; // report pattern progress every Nth pattern
   integer verbose;      // message verbosity level
   integer debug;      // enable debug level
   integer test_setup_runs; // counts the number of executed test_setups
   integer test_setup_only_once; // flag to trigger only one execution of test_setup
   integer data_i, n, cur_pat, start_pat, end_pat, last_pat, total_pats, csci, fsci, cur_stmt;
   integer v_count, v_count_per_pat;  // track the cycle count and cycle/pattern count (helpful for the simulator GUI)
   integer SSHIFTS;
   integer diagf, diagm;
   integer sertmg;
   integer the_wft_id, wft_id_s;
   integer ser_pats;
   integer first_pat;
   event start_part, end_part;
   `define NBRTOPS 7
   integer csim_op;
   reg [32*8:1] RT_OPS [0:`NBRTOPS];
   integer      rt_ops [0:`NBRTOPS-1];
   integer      tdfm;
   integer lp_addr, lp_count, lp_max;
   reg [0:(8*FILELENGTH)-1] TDATA_FILE;

   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] ALLINSIGS, ALLOUTSIGS;
   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] TMPINSIGS_V,TMPINSIGS_T,TMPINSIGS_V_S,TMPINSIGS_T_S;
   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] TMPOUTSIGS_V,TMPOUTSIGS_T,TMPOUTSIGS_V_S,TMPOUTSIGS_T_S;
   reg [NINPUTS+NOUTPUTS-1:0] ALLINSIGIDS, ALLOUTSIGIDS, ALLINSIGIDS_S, ALLOUTSIGIDS_S;
   reg [NSTMTS-1:0] opcode, popcode;
   event force_scells;
   event strobe_scells;
   event release_scells;
   reg [65:0] memel, memall [1:2031];
   reg [0:(8*NAMELENGTH)-1] CH_NAMES [0:NCHAINS-1];
   reg [0:(8*NAMELENGTH)-1] CH_PINS [0:NCHAINS-1];
   reg [0:MAXCHLEN-1] LOD, LOAD[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] UNL, UNLOAD[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] UNLM;
   reg [0:MAXCHLEN-1] SERIALM;
   reg [0:MAXCHLEN-1] CH_INPINV[0:NCHAINS-1], CH_OUTINV[0:NCHAINS-1];
   wire [0:NCHAINS-1] SCANOUT;
   reg [0:MAXCHLEN-1] CHOUT, CHAINOUT[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] CHAINOUT0;
   reg [0:MAXCHLEN-1] LOD0;
   reg [5:0] the_sids [0:SIG_IDS-1];
   reg [MAX_WIDTH-1:0] the_sigs [0:SIG_IDS-1];
   reg strobe_en;
   reg [SIG_IDS-1:0] sid_args ;
   reg [2*CUM_WIDTH-1:0] sval_args;
   reg [8*NAMELENGTH-1:0]  SignalIDName [0:46];
   reg [2:0]  SignalIDType [0:46];
   reg [4:0]  SignalIDWidth [0:46];
   reg [(8*NAMELENGTH-1):0]  WFTIDName [0:4];
   reg [0:(8*NAMELENGTH-1)] StmtNames [0:NSTMTS];
   reg [0:(8*FILELENGTH)-1] diag_file;

   reg SET_TIME_con ;
   reg ALARM_con ;
   reg HOURS_con ;
   reg MINUTES_con ;
   reg TOGGLE_con ;
   reg CLOCK_con ;
   reg RESETN_con ;
   reg TEST_MODE_con ;
   reg TEST_SE_con ;
   reg TEST_SI_con ;
   wire SPEAKER_con ;
   wire \HR[13]  ;
   wire \HR[12]  ;
   wire \HR[11]  ;
   wire \HR[10]  ;
   wire \HR[9]  ;
   wire \HR[8]  ;
   wire \HR[7]  ;
   wire \HR[6]  ;
   wire \HR[5]  ;
   wire \HR[4]  ;
   wire \HR[3]  ;
   wire \HR[2]  ;
   wire \HR[1]  ;
   wire \HR[0]  ;
   wire \MIN[13]  ;
   wire \MIN[12]  ;
   wire \MIN[11]  ;
   wire \MIN[10]  ;
   wire \MIN[9]  ;
   wire \MIN[8]  ;
   wire \MIN[7]  ;
   wire \MIN[6]  ;
   wire \MIN[5]  ;
   wire \MIN[4]  ;
   wire \MIN[3]  ;
   wire \MIN[2]  ;
   wire \MIN[1]  ;
   wire \MIN[0]  ;
   wire AM_PM_con ;

   wire [0:(8*NAMELENGTH-1)] cur_StmtName;
   assign cur_StmtName = StmtNames[cur_stmt] ;


   CORE dut( 
     .SET_TIME ( SET_TIME_con ),
     .ALARM ( ALARM_con ),
     .HOURS ( HOURS_con ),
     .MINUTES ( MINUTES_con ),
     .TOGGLE ( TOGGLE_con ),
     .CLOCK ( CLOCK_con ),
     .RESETN ( RESETN_con ),
     .TEST_MODE ( TEST_MODE_con ),
     .TEST_SE ( TEST_SE_con ),
     .TEST_SI ( TEST_SI_con ),
     .SPEAKER ( SPEAKER_con ),
     .HR ( { \HR[13] ,
        \HR[12] ,
        \HR[11] ,
        \HR[10] ,
        \HR[9] ,
        \HR[8] ,
        \HR[7] ,
        \HR[6] ,
        \HR[5] ,
        \HR[4] ,
        \HR[3] ,
        \HR[2] ,
        \HR[1] ,
        \HR[0] } ),
     .MIN ( { \MIN[13] ,
        \MIN[12] ,
        \MIN[11] ,
        \MIN[10] ,
        \MIN[9] ,
        \MIN[8] ,
        \MIN[7] ,
        \MIN[6] ,
        \MIN[5] ,
        \MIN[4] ,
        \MIN[3] ,
        \MIN[2] ,
        \MIN[1] ,
        \MIN[0] } ),
     .AM_PM ( AM_PM_con )
  );


   task save_context;
     begin
       wft_id_s = the_wft_id;
       TMPINSIGS_V_S = TMPINSIGS_V;
       TMPOUTSIGS_V_S = TMPOUTSIGS_V;
       TMPINSIGS_T_S = TMPINSIGS_T;
       TMPOUTSIGS_T_S = TMPOUTSIGS_T;
       ALLOUTSIGIDS_S = ALLOUTSIGIDS;
       ALLINSIGIDS_S = ALLINSIGIDS;
     end
   endtask 

   task restore_context;
     begin
       the_wft_id = wft_id_s;
       TMPINSIGS_V = TMPINSIGS_V_S;
       TMPOUTSIGS_V = TMPOUTSIGS_V_S;
       TMPINSIGS_T = TMPINSIGS_T_S;
       TMPOUTSIGS_T = TMPOUTSIGS_T_S;
       ALLOUTSIGIDS = ALLOUTSIGIDS_S;
       ALLINSIGIDS = ALLINSIGIDS_S;
     end
   endtask 

   task resolve_signal;
     input reg [5:0] sid;
   begin
     if (SignalIDType[sid] != 3) the_sids[0] = sid;
     else begin
       case (sid)
         'd40: begin // _pi
                 the_sids[9] = 1; the_sids[8] = 5; the_sids[7] = 2; the_sids[6] = 3; the_sids[5] = 6; the_sids[4] = 0; the_sids[3] = 7; the_sids[2] = 8; the_sids[1] = 9;
                 the_sids[0] = 4;
               end
         'd41: begin // all_inputs
                 the_sids[9] = 1; the_sids[8] = 5; the_sids[7] = 2; the_sids[6] = 3; the_sids[5] = 6; the_sids[4] = 0; the_sids[3] = 7; the_sids[2] = 8; the_sids[1] = 9;
                 the_sids[0] = 4;
               end
         'd42: begin // _po
                 the_sids[29] = 39; the_sids[28] = 24; the_sids[27] = 14; the_sids[26] = 13; the_sids[25] = 12; the_sids[24] = 11; the_sids[23] = 23; the_sids[22] = 22; the_sids[21] = 21; the_sids[20] = 20; the_sids[19] = 19; the_sids[18] = 18; the_sids[17] = 17; the_sids[16] = 16; the_sids[15] = 15; the_sids[14] = 38; the_sids[13] = 28; the_sids[12] = 27; the_sids[11] = 26; the_sids[10] = 25; the_sids[9] = 37; the_sids[8] = 36; the_sids[7] = 35; the_sids[6] = 34; the_sids[5] = 33; the_sids[4] = 32; the_sids[3] = 31; the_sids[2] = 30; the_sids[1] = 29;
                 the_sids[0] = 10;
               end
         'd43: begin // _si
                
                 the_sids[0] = 9;
               end
         'd44: begin // all_outputs
                 the_sids[29] = 39; the_sids[28] = 24; the_sids[27] = 14; the_sids[26] = 13; the_sids[25] = 12; the_sids[24] = 11; the_sids[23] = 23; the_sids[22] = 22; the_sids[21] = 21; the_sids[20] = 20; the_sids[19] = 19; the_sids[18] = 18; the_sids[17] = 17; the_sids[16] = 16; the_sids[15] = 15; the_sids[14] = 38; the_sids[13] = 28; the_sids[12] = 27; the_sids[11] = 26; the_sids[10] = 25; the_sids[9] = 37; the_sids[8] = 36; the_sids[7] = 35; the_sids[6] = 34; the_sids[5] = 33; the_sids[4] = 32; the_sids[3] = 31; the_sids[2] = 30; the_sids[1] = 29;
                 the_sids[0] = 10;
               end
         'd45: begin // _clk
                 the_sids[1] = 5;
                 the_sids[0] = 6;
               end
         'd46: begin // _so
                
                 the_sids[0] = 10;
               end
          default: begin $display("\nXTB Error: unrecognized signal id %d (valid range is 0..%d). Exiting...",sid, SIG_IDS); $finish; end
       endcase
     end
   end
   endtask

   task get_stb_sig;
     input reg [5:0] sid ;
     output reg [MAX_WIDTH-1:0] strsig;
   begin
     case (sid)
       'd10:	strsig[0:0] = 	SPEAKER_con ;
       'd11:	strsig[0:0] = 	\HR[13]  ;
       'd12:	strsig[0:0] = 	\HR[12]  ;
       'd13:	strsig[0:0] = 	\HR[11]  ;
       'd14:	strsig[0:0] = 	\HR[10]  ;
       'd15:	strsig[0:0] = 	\HR[9]  ;
       'd16:	strsig[0:0] = 	\HR[8]  ;
       'd17:	strsig[0:0] = 	\HR[7]  ;
       'd18:	strsig[0:0] = 	\HR[6]  ;
       'd19:	strsig[0:0] = 	\HR[5]  ;
       'd20:	strsig[0:0] = 	\HR[4]  ;
       'd21:	strsig[0:0] = 	\HR[3]  ;
       'd22:	strsig[0:0] = 	\HR[2]  ;
       'd23:	strsig[0:0] = 	\HR[1]  ;
       'd24:	strsig[0:0] = 	\HR[0]  ;
       'd25:	strsig[0:0] = 	\MIN[13]  ;
       'd26:	strsig[0:0] = 	\MIN[12]  ;
       'd27:	strsig[0:0] = 	\MIN[11]  ;
       'd28:	strsig[0:0] = 	\MIN[10]  ;
       'd29:	strsig[0:0] = 	\MIN[9]  ;
       'd30:	strsig[0:0] = 	\MIN[8]  ;
       'd31:	strsig[0:0] = 	\MIN[7]  ;
       'd32:	strsig[0:0] = 	\MIN[6]  ;
       'd33:	strsig[0:0] = 	\MIN[5]  ;
       'd34:	strsig[0:0] = 	\MIN[4]  ;
       'd35:	strsig[0:0] = 	\MIN[3]  ;
       'd36:	strsig[0:0] = 	\MIN[2]  ;
       'd37:	strsig[0:0] = 	\MIN[1]  ;
       'd38:	strsig[0:0] = 	\MIN[0]  ;
       'd39:	strsig[0:0] = 	AM_PM_con ;
       default: begin $display("\nXTB Error: unrecognized output signal id %d. Exiting...",sid); $finish; end
     endcase
   end
   endtask

   task set_force_sig;
     input reg [SIG_IDS-1:0] sid ;
   begin
     case (sid)
       'd0: SET_TIME_con 	= ALLINSIGS[sid];
       'd1: ALARM_con 	= ALLINSIGS[sid];
       'd2: HOURS_con 	= ALLINSIGS[sid];
       'd3: MINUTES_con 	= ALLINSIGS[sid];
       'd4: TOGGLE_con 	= ALLINSIGS[sid];
       'd5: CLOCK_con 	= ALLINSIGS[sid];
       'd6: RESETN_con 	= ALLINSIGS[sid];
       'd7: TEST_MODE_con 	= ALLINSIGS[sid];
       'd8: TEST_SE_con 	= ALLINSIGS[sid];
       'd9: TEST_SI_con 	= ALLINSIGS[sid];
       default: begin $display("\nXTB Error: unrecognized (input) signal id %d (valid range is 0..%d). Exiting...",sid, SIG_IDS-1); $finish; end
     endcase
   end
   endtask 

   always  begin: force_sigs_p
     reg [SIG_IDS-1:0] sid; 
     reg [MAX_SIGW-1:0] sig;
     fork
        forever @(ALLINSIGS[0]) set_force_sig('d`SET_TIME );
        forever @(ALLINSIGS[1]) set_force_sig('d`ALARM );
        forever @(ALLINSIGS[2]) set_force_sig('d`HOURS );
        forever @(ALLINSIGS[3]) set_force_sig('d`MINUTES );
        forever @(ALLINSIGS[4]) set_force_sig('d`TOGGLE );
        forever @(ALLINSIGS[5]) set_force_sig('d`CLOCK );
        forever @(ALLINSIGS[6]) set_force_sig('d`RESETN );
        forever @(ALLINSIGS[7]) set_force_sig('d`TEST_MODE );
        forever @(ALLINSIGS[8]) set_force_sig('d`TEST_SE );
        forever @(ALLINSIGS[9]) set_force_sig('d`TEST_SI );
     join
   end

   task measure_out_sig;
     input reg [SIG_IDS-1:0] sid ;
     input reg [MAX_WIDTH-1:0] xsig;
     input integer  stmtid;
     reg [MAX_WIDTH-1:0] csig;
     integer errshown, abit, cpat;
   begin
     errshown = 0;
     cpat = cur_pat < 0 ? 0 : cur_pat;
     get_stb_sig(sid,csig);
     for (abit = 0; abit < SignalIDWidth[sid]; abit = abit + 1) begin
       if (xsig[abit] !== 1'bx) begin
         if (xsig[abit] !== csig[abit]) begin
           if (errshown == 0) $display(">>>  Error during %0s pattern %0d", StmtNames[stmtid], cpat);
           if (SignalIDWidth[sid] <= 1) begin 
             $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, signal %0s", $time, v_count, xsig[abit], csig[abit], SignalIDName[sid]);
             if (diagf) begin 
               if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b)", SignalIDName[sid], v_count, xsig[abit], csig[abit]);
               else $fdisplay(diagf, "  %0d %0s (exp=%b, got=%b)", cpat, SignalIDName[sid], xsig[abit], csig[abit]);
             end 
           end 
           else begin 
             $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, signal %0s[%0d]", $time, v_count, xsig[abit], csig[abit], SignalIDName[sid], abit);
             if (diagf) begin 
               if (diagm==2) $fdisplay(diagf, "  C %0s[%0d] %0d (exp=%b, got=%b)", SignalIDName[sid], abit, v_count, xsig[abit], csig[abit]);
               else $fdisplay(diagf, "  %0d %0s[%d] (exp=%b, got=%b)", cpat, SignalIDName[sid], abit, xsig[abit], csig[abit]);
             end 
           end 
           nbfails = nbfails + 1;
           errshown = 1;
         end 
       end 
     end 
   end 
   endtask

   task measure_scan_out;
     input reg [SIG_IDS-1:0] sid ;
     input reg [MAX_WIDTH-1:0] xsig;
     input integer  chain;
     reg [MAX_WIDTH-1:0] csig;
     integer errshown, patoff;
   begin
     errshown = 0;
     get_stb_sig(sid, csig);
     if ((xsig[0] !==1'bx) && (xsig[0] !== csig[0])) begin
       patoff = (loads > 1 || cur_pat <= 0) ? 0 : 1;
       if (prev_error != cur_pat) begin
         if (cur_pat <= 0 || cur_pat == last_pat && loads > 1) begin
           $display(">>>  Error during scan pattern %0d %s", (cur_pat < 0) ? 0 : cur_pat,  (cur_pat == last_pat) ? "(detected from final pattern unload)" : "");
         end
         else begin
           if (loads > 1) $display(">>>  Error during scan pattern %0d (detected from %0d load/unload)", cur_pat, loads);
           else begin $display(">>>  Error during scan pattern %0d (detected from unload of pattern %0d)", cur_pat, cur_pat-1); end
         end 
         prev_error = cur_pat;
       end
       $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, chain %0s, pin %0s, scan cell %0d", $time, v_count, xsig[0], csig[0], CH_NAMES[chain], SignalIDName[sid], fsci);
       if (diagf) begin 
         if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b)", SignalIDName[sid], v_count, xsig[0], csig[0]);
          else $fdisplay(diagf, "  %0d %0s %0d (exp=%b, got=%b)", cur_pat-patoff, SignalIDName[sid], fsci, xsig[0], csig[0]);
       end 
       nbfails = nbfails + 1;
     end
   end 
   endtask

   always begin: measure_sigs_p
    fork
     forever @(ALLOUTSIGS['d`SPEAKER]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `load_unloadStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt )
       if (cur_stmt ==`load_unloadStmt) measure_scan_out('d`SPEAKER,ALLOUTSIGS[10], 0); 
       else measure_out_sig('d`SPEAKER,ALLOUTSIGS[10], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[13] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[13] ,ALLOUTSIGS[11], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[12] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[12] ,ALLOUTSIGS[12], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[11] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[11] ,ALLOUTSIGS[13], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[10] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[10] ,ALLOUTSIGS[14], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[9] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[9] ,ALLOUTSIGS[15], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[8] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[8] ,ALLOUTSIGS[16], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[7] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[7] ,ALLOUTSIGS[17], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[6] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[6] ,ALLOUTSIGS[18], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[5] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[5] ,ALLOUTSIGS[19], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[4] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[4] ,ALLOUTSIGS[20], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[3] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[3] ,ALLOUTSIGS[21], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[2] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[2] ,ALLOUTSIGS[22], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[1] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[1] ,ALLOUTSIGS[23], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\HR[0] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\HR[0] ,ALLOUTSIGS[24], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[13] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[13] ,ALLOUTSIGS[25], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[12] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[12] ,ALLOUTSIGS[26], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[11] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[11] ,ALLOUTSIGS[27], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[10] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[10] ,ALLOUTSIGS[28], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[9] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[9] ,ALLOUTSIGS[29], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[8] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[8] ,ALLOUTSIGS[30], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[7] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[7] ,ALLOUTSIGS[31], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[6] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[6] ,ALLOUTSIGS[32], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[5] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[5] ,ALLOUTSIGS[33], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[4] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[4] ,ALLOUTSIGS[34], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[3] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[3] ,ALLOUTSIGS[35], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[2] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[2] ,ALLOUTSIGS[36], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[1] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[1] ,ALLOUTSIGS[37], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\MIN[0] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`\MIN[0] ,ALLOUTSIGS[38], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`AM_PM]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt ) measure_out_sig('d`AM_PM,ALLOUTSIGS[39], cur_stmt); 
     end
    join
   end 

   task undef_wfc;
     input reg [1:0] wfc;
     input reg [5:0] sid;
     input integer wftid;
   begin
     $display("XTB Error: unrecognized %s value (WFC):%0b, on signal %0s for WFT %0s. Exiting...", wfc[1]?"strobe":"force", wfc[0], SignalIDName[sid], WFTIDName[wftid]);
     $finish;
   end
   endtask

   task apply__multiclock_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd1, 'd2, 'd3, 'd0, 'd7, 'd8, 'd9, 'd4: // ALARM, HOURS, MINUTES, SET_TIME, TEST_MODE, TEST_SE, TEST_SI, TOGGLE_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd39, 'd24, 'd14, 'd13, 'd12, 'd11, 'd23, 'd22, 'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd38, 'd28, 'd27, 'd26, 'd25, 'd37, 'd36, 'd35, 'd34, 'd33, 'd32, 'd31, 'd30, 'd29, 'd10: // AM_PM, \HR[0] , \HR[10] , \HR[11] , \HR[12] , \HR[13] , \HR[1] , \HR[2] , \HR[3] , \HR[4] , \HR[5] , \HR[6] , \HR[7] , \HR[8] , \HR[9] , \MIN[0] , \MIN[10] , \MIN[11] , \MIN[12] , \MIN[13] , \MIN[1] , \MIN[2] , \MIN[3] , \MIN[4] , \MIN[5] , \MIN[6] , \MIN[7] , \MIN[8] , \MIN[9] , SPEAKER_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd5: // CLOCK
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd6: // RESETN
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b1;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__default_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd1, 'd2, 'd3, 'd0, 'd7, 'd8, 'd9, 'd4: // ALARM, HOURS, MINUTES, SET_TIME, TEST_MODE, TEST_SE, TEST_SI, TOGGLE_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd39, 'd24, 'd14, 'd13, 'd12, 'd11, 'd23, 'd22, 'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd38, 'd28, 'd27, 'd26, 'd25, 'd37, 'd36, 'd35, 'd34, 'd33, 'd32, 'd31, 'd30, 'd29, 'd10: // AM_PM, \HR[0] , \HR[10] , \HR[11] , \HR[12] , \HR[13] , \HR[1] , \HR[2] , \HR[3] , \HR[4] , \HR[5] , \HR[6] , \HR[7] , \HR[8] , \HR[9] , \MIN[0] , \MIN[10] , \MIN[11] , \MIN[12] , \MIN[13] , \MIN[1] , \MIN[2] , \MIN[3] , \MIN[4] , \MIN[5] , \MIN[6] , \MIN[7] , \MIN[8] , \MIN[9] , SPEAKER_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd5: // CLOCK
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd6: // RESETN
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b1;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_launch_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd1, 'd2, 'd3, 'd0, 'd7, 'd8, 'd9, 'd4: // ALARM, HOURS, MINUTES, SET_TIME, TEST_MODE, TEST_SE, TEST_SI, TOGGLE_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
         'd39, 'd24, 'd14, 'd13, 'd12, 'd11, 'd23, 'd22, 'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd38, 'd28, 'd27, 'd26, 'd25, 'd37, 'd36, 'd35, 'd34, 'd33, 'd32, 'd31, 'd30, 'd29, 'd10: // AM_PM, \HR[0] , \HR[10] , \HR[11] , \HR[12] , \HR[13] , \HR[1] , \HR[2] , \HR[3] , \HR[4] , \HR[5] , \HR[6] , \HR[7] , \HR[8] , \HR[9] , \MIN[0] , \MIN[10] , \MIN[11] , \MIN[12] , \MIN[13] , \MIN[1] , \MIN[2] , \MIN[3] , \MIN[4] , \MIN[5] , \MIN[6] , \MIN[7] , \MIN[8] , \MIN[9] , SPEAKER_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
         'd5: // CLOCK
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
         'd6: // RESETN
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b1;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd1, 'd2, 'd3, 'd0, 'd7, 'd8, 'd9, 'd4: // ALARM, HOURS, MINUTES, SET_TIME, TEST_MODE, TEST_SE, TEST_SI, TOGGLE_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
         'd39, 'd24, 'd14, 'd13, 'd12, 'd11, 'd23, 'd22, 'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd38, 'd28, 'd27, 'd26, 'd25, 'd37, 'd36, 'd35, 'd34, 'd33, 'd32, 'd31, 'd30, 'd29, 'd10: // AM_PM, \HR[0] , \HR[10] , \HR[11] , \HR[12] , \HR[13] , \HR[1] , \HR[2] , \HR[3] , \HR[4] , \HR[5] , \HR[6] , \HR[7] , \HR[8] , \HR[9] , \MIN[0] , \MIN[10] , \MIN[11] , \MIN[12] , \MIN[13] , \MIN[1] , \MIN[2] , \MIN[3] , \MIN[4] , \MIN[5] , \MIN[6] , \MIN[7] , \MIN[8] , \MIN[9] , SPEAKER_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
         'd5: // CLOCK
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
         'd6: // RESETN
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b1;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_launch_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd1, 'd2, 'd3, 'd0, 'd7, 'd8, 'd9, 'd4: // ALARM, HOURS, MINUTES, SET_TIME, TEST_MODE, TEST_SE, TEST_SI, TOGGLE_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
         'd39, 'd24, 'd14, 'd13, 'd12, 'd11, 'd23, 'd22, 'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd38, 'd28, 'd27, 'd26, 'd25, 'd37, 'd36, 'd35, 'd34, 'd33, 'd32, 'd31, 'd30, 'd29, 'd10: // AM_PM, \HR[0] , \HR[10] , \HR[11] , \HR[12] , \HR[13] , \HR[1] , \HR[2] , \HR[3] , \HR[4] , \HR[5] , \HR[6] , \HR[7] , \HR[8] , \HR[9] , \MIN[0] , \MIN[10] , \MIN[11] , \MIN[12] , \MIN[13] , \MIN[1] , \MIN[2] , \MIN[3] , \MIN[4] , \MIN[5] , \MIN[6] , \MIN[7] , \MIN[8] , \MIN[9] , SPEAKER_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
         'd5: // CLOCK
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
         'd6: // RESETN
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b1;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task resolve_wft;
     input integer wftid ;
   begin
     if (wftid > WFT_IDS || wftid <0) begin 
       $display("\nXTB Error: undefined WFT id %0d (valid range is 0..%0d). Exiting...",wftid, WFT_IDS);
       $finish;
     end
     the_wft_id = wftid;
   end
   endtask

   task apply_wft; 
     input integer wftid ;
   begin
     case (wftid) 
       'd0: apply__multiclock_capture_WFT_WFT;
       'd1: apply__default_WFT_WFT;
       'd2: apply__allclock_launch_WFT_WFT;
       'd3: apply__allclock_capture_WFT_WFT;
       'd4: apply__allclock_launch_capture_WFT_WFT;
       default:begin $display("\nXTB Error: undefined WFT id %d. Exiting...",wftid); $finish; end
     endcase
   end
   endtask 

   task  complete_cycle;
     input integer wft_id ;
   begin
     case(wft_id)
       'd0: #(100); // _multiclock_capture_WFT_
       'd1: #(100); // _default_WFT_
       'd2: #(100); // _allclock_launch_WFT_
       'd3: #(100); // _allclock_capture_WFT_
       'd4: #(100); // _allclock_launch_capture_WFT_
     endcase
   end
   endtask

   task set_args;
     input reg [5:0] nargs;
     integer i, na;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [SIG_IDS_W-1:0] sid; 
   begin
     na = 0; sid_args = 'b0; sval_args = 'b0;
     while (na < nargs) begin
       data_i = data_i + 1;
       memel = memall[data_i];
       sid = memel[SIG_IDS_W-1:0];
       if (sid > SIG_IDS-1) begin
         $display($time, "\nXTB Error: Passing wrong signal ID (%0b), valid range is 1..%0d. Exiting...", sid, SIG_IDS-1);
         $finish; 
       end
       sid_args[sid] = 1'b1;
       sidx = sig_idx(sid);
       for (i = 0; i < 2*SignalIDWidth[sid]; i = i + 1)
         sval_args[sidx+i] = memel[i+SIG_IDS_W];
       na=na+1; 
    end  
  end 
  endtask

   function [2*CUM_WIDTH-1:0] sig_idx;
     input reg [SIG_IDS_W-1:0] sid;
     integer i; 
   begin
     sig_idx = 0;
     for (i = 0; i < sid; i = i + 1) sig_idx = sig_idx+2*SignalIDWidth[i];
   end 
   endfunction

   task  assign_ival;
     input reg [SIG_IDS_W-1:0] sid;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [2*MAX_WIDTH-1:0] sval;
     integer i;
   begin 
     sidx = sig_idx(sid);
     for (i = 0; i<2*SignalIDWidth[sid]; i = i + 1) sval[i] = sval_args[sidx+i];
     assign_val(sid , sval);
   end 
   endtask

   task  assign_val;
     input reg [SIG_IDS_W-1:0] sid;
     input reg [2*MAX_WIDTH-1:0] sval;
     reg [MAX_WIDTH-1:0] nb; 
     reg [7:0] idx;
     reg [5:0] n, ns;
   begin
     if (sid > SIG_IDS-1 || sid < 0) begin
       $display("\nXTB Error: Passing wrong signal ID (%d), valid range is 1..%0d. Exiting...", sid, SIG_IDS-1);
       $finish;
     end
     resolve_signal(sid);
     idx = 0; 
     ns = (SignalIDType[sid]==3) ? SignalIDWidth[sid] : 1;
     for (n = 0; n < ns; n = n + 1)
     begin
       if (sval[idx+SignalIDWidth[sid]] === 1'b1) begin
         for (nb = 0; nb < SignalIDWidth[the_sids[n]]; nb = nb + 1) begin
           TMPOUTSIGS_V[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb];
           TMPOUTSIGS_T[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb+SignalIDWidth[sid]];
           ALLOUTSIGIDS[the_sids[n]] = 1'b1; 
           if (sval[idx+nb] !== 1'bx)
             ALLINSIGIDS[the_sids[n]] = 1'b0;
         end
       end
       else begin
         for (nb = 0; nb < SignalIDWidth[the_sids[n]]; nb = nb + 1) begin
           TMPINSIGS_V[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb];
           TMPINSIGS_T[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb+SignalIDWidth[sid]];
           ALLINSIGIDS[the_sids[n]] = 1'b1;
           ALLOUTSIGIDS[the_sids[n]] = 1'b0;
       end 
     end
     idx = idx+SignalIDWidth[the_sids[n]];
     end 
   end 
   endtask

   task  check_sid_args;
     input reg [(NAMELENGTH-1):0] tname;
     input reg [SIG_IDS-1:0] vargs ;
     input reg [SIG_IDS-1:0] cargs ;
     integer i;
   begin
     for (i = 0; i < SIG_IDS-1; i = i + 1)
       if (cargs[i] === 1'b1 && vargs[i] !== 1'b1) begin
         $display("\nXTB Error: Passing wrong signal argument (%s), to Macro/Procedure %s. Exiting...", SignalIDName[i], tname); 
         $finish;
       end 
   end 
   endtask

   task  assign_stmt;
     input integer wftid ;
   begin
     v_count = v_count+1;
     v_count_per_pat = v_count_per_pat+1;
     if (verbose >= 4) $display("XTB: Starting V# %0d at time %0t", v_count, $time);
     apply_wft(wftid);
     complete_cycle(wftid);
   end
   endtask

   task display_stmt;
     input integer stmtid;
   begin
     $display("XTB: Processed statement: %0s", StmtNames[stmtid]);
   end
   endtask

   task read_data;
     integer tdf;
   begin
     tdf = $fopen(TDATA_FILE, "r");
     if (!tdf) begin 
       $display("XTB Error: cannot open %0s file. Exiting...\n", TDATA_FILE);
       $finish; 
      end 
      $fclose(tdf); 
     if (tdfm > 0) $display("XTB: Setting test data file to \"%0s\" (at %0s). Running simulation with new database...", TDATA_FILE, tdfm==1?"compile-time":"runtime");
     else if (verbose >= 1) $display("XTB: Reading test data file \"%0s\" ", TDATA_FILE);
     $readmemb(TDATA_FILE, memall); 
    end
    endtask

   task measure_chain_out;
     input reg [NCHAINS-1:0] chid;
     integer bi, errshown, patoff, prefo;
     integer tsc;
     reg [0:MAXCHLEN-1]  UNLM;
   begin
     tsc = 0;
     prefo = 0;
     UNLM = ~('b0);
     CHAINOUT[0] = (CHAINOUT0);
     UNL = UNLOAD[chid] << prefo;
     CHOUT = CHAINOUT[chid] ^ CH_OUTINV[chid];

     for (bi = 0; bi < MAXCHLEN; bi = bi + 1)
       if (UNL[bi] === 1'bx) UNLM[bi] = 1'b0;

     for (bi = 0; bi < prefo; bi = bi + 1) UNLM[MAXCHLEN-1-bi] = 1'b0;

     if ((UNL&UNLM) !== (CHOUT&UNLM)) begin
       patoff = (loads > 1 || cur_pat <= 0) ? 0 : 1;
     if (cur_pat <= 0 || cur_pat == last_pat && loads > 1) begin
       $display(">>>  Error during scan pattern %0d %s", (cur_pat<0)?0:cur_pat, (cur_pat==last_pat)?"(detected from final parallel pattern unload)":"");
     end
     else begin
       if (loads > 1) $display(">>>  Error during scan pattern %0d (detected from %0d parallel load/unload)", cur_pat, loads);
       else begin $display(">>>  Error during scan pattern %0d (detected from parallel unload of pattern %0d)", cur_pat, cur_pat-1); end
     end
       for (bi = 0; bi < MAXCHLEN-prefo; bi=bi + 1) begin
         if ((UNL[bi] !== 1'bx) && (UNL[bi] !== CHOUT[bi])) begin
           $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, chain %0s, pin %0s, scan cell %0d", $time, sertmg?v_count+1+bi+prefo:v_count, UNL[bi], CHOUT[bi], CH_NAMES[chid], CH_PINS[chid], bi+prefo+tsc);
           if (diagf) begin 
           if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b) ", CH_PINS[chid], v_count, UNL[bi], CHOUT[bi]);
           else $fdisplay(diagf, "  %0d %0s %0d (exp=%b, got=%b)",
               cur_pat-patoff, CH_PINS[chid], bi+prefo+tsc, UNL[bi], CHOUT[bi]);
           end 
           nbfails = nbfails + 1;
          end 
       end  
     end
   end 
   endtask

   task test_setup ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     if (test_setup_only_once > 0 && test_setup_runs > 0) begin
       if (verbose >= 2) $display("XTB: Skipping macro test_setup...");
       disable test_setup;
     end
     test_setup_runs = test_setup_runs + 1;
     if (verbose >= 2) $display("XTB: Starting macro test_setup..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("test_setup",47'b1, idargs);
     resolve_wft(1);

     assign_val('d`all_inputs , 20'b0000000000XXXXXXXXXX);
     assign_val('d`all_outputs , 60'b111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     assign_val('d`CLOCK , 2'b00);
     assign_val('d`RESETN , 2'b01);
     assign_val('d`TEST_MODE , 2'b01);
     assign_stmt(the_wft_id);

     assign_stmt(the_wft_id);

   end 
   endtask

   task shift_0 ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
     input integer stsci;
     input reg stroben;
   begin
    csci = stsci+0; prev_error = -2;
    while (csci < 40) begin
     fsci = csci;
     if (verbose >= 2) $display("XTB: shift %0d, at %0t ", csci, $time);
     resolve_wft(1);
     assign_val('d`_clk , 4'bZ011);
         if (idargs[43] === 1'b1 || idargs[9] === 1'b1) begin 
           LOD=LOAD[0]; assign_val('d`TEST_SI , {1'b0, LOD[csci+0]});
         end
         if(stroben && (idargs[46] === 1'b1 || idargs[10] === 1'b1)) begin 
           UNL = UNLOAD[0]; assign_val('d`SPEAKER , {1'b1,  UNL[csci+0]});
         end
     assign_stmt(the_wft_id);
     csci = csci+1;
    end
   end
   endtask


   always /* ParallelShiftMode */ @(strobe_scells) begin
     CHAINOUT0[0:31] = {dut.SPEAKER , dut.U1.U5.CURRENT_STATE_reg.SD , dut.U1.U7.INT_CLK_reg.SD , dut.U1.U7.COUNT_reg.SD , dut.U1.U2.U3.MINUTES_OUT_reg_5_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_4_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_3_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_2_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_1_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_0_.SD , dut.U1.U2.U3.HRS_OUT_reg_3_.SD , dut.U1.U2.U3.HRS_OUT_reg_2_.SD , dut.U1.U2.U3.HRS_OUT_reg_1_.SD , dut.U1.U2.U3.HRS_OUT_reg_0_.SD , dut.U1.U2.U3.AM_PM_OUT_reg.SD , dut.U1.U2.U0.MINS_reg.SD , dut.U1.U2.U0.HOURS_reg.SD , dut.U1.U2.U0.CURRENT_STATE_reg_1_.SD , dut.U1.U2.U0.CURRENT_STATE_reg_0_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_5_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_4_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_3_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_2_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_1_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_0_.SD , dut.U1.U1.U2.HOURS_OUT_reg_3_.SD , dut.U1.U1.U2.HOURS_OUT_reg_2_.SD , dut.U1.U1.U2.HOURS_OUT_reg_1_.SD , dut.U1.U1.U2.HOURS_OUT_reg_0_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_5_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_4_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_3_.SD };
     CHAINOUT0[32:39] = {dut.U1.U1.U2.CURRENT_SECS_reg_2_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_1_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_0_.SD , dut.U1.U1.U2.AM_PM_OUT_reg.SD , dut.U1.U1.U1.SECS_reg.SD , dut.U1.U1.U1.MINS_reg.SD , dut.U1.U1.U1.HOURS_reg.SD , dut.U1.U1.U1.CURRENT_STATE_reg_1_.SD };
   end

   `define CELL0IN0 dut.U1.U1.U1.CURRENT_STATE_reg_0_.SD
   `define CHAININ0 {dut.U1.U5.CURRENT_STATE_reg.SD , dut.U1.U7.INT_CLK_reg.SD , dut.U1.U7.COUNT_reg.SD , dut.U1.U2.U3.MINUTES_OUT_reg_5_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_4_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_3_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_2_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_1_.SD , dut.U1.U2.U3.MINUTES_OUT_reg_0_.SD , dut.U1.U2.U3.HRS_OUT_reg_3_.SD , dut.U1.U2.U3.HRS_OUT_reg_2_.SD , dut.U1.U2.U3.HRS_OUT_reg_1_.SD , dut.U1.U2.U3.HRS_OUT_reg_0_.SD , dut.U1.U2.U3.AM_PM_OUT_reg.SD , dut.U1.U2.U0.MINS_reg.SD , dut.U1.U2.U0.HOURS_reg.SD , dut.U1.U2.U0.CURRENT_STATE_reg_1_.SD , dut.U1.U2.U0.CURRENT_STATE_reg_0_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_5_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_4_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_3_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_2_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_1_.SD , dut.U1.U1.U2.MINUTES_OUT_reg_0_.SD , dut.U1.U1.U2.HOURS_OUT_reg_3_.SD , dut.U1.U1.U2.HOURS_OUT_reg_2_.SD , dut.U1.U1.U2.HOURS_OUT_reg_1_.SD , dut.U1.U1.U2.HOURS_OUT_reg_0_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_5_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_4_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_3_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_2_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_1_.SD , dut.U1.U1.U2.CURRENT_SECS_reg_0_.SD , dut.U1.U1.U2.AM_PM_OUT_reg.SD , dut.U1.U1.U1.SECS_reg.SD , dut.U1.U1.U1.MINS_reg.SD , dut.U1.U1.U1.HOURS_reg.SD , dut.U1.U1.U1.CURRENT_STATE_reg_1_.SD ,  `CELL0IN0 }


   task p_shift_0 ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
     integer i, j;
   begin
     if (~(idargs[43] | idargs[9] | idargs[46] | idargs[10] )) 
       disable p_shift_0 ; 
     if (SSHIFTS < MAXCHLEN) begin
         if (verbose >= 2) $display("XTB: (parallel) shift, at %0t  ", $time);
         resolve_wft(1);
     fork 
       begin: b1 
         #40 ;
         -> strobe_scells;
         repeat (SYNC_LATENCY) #0;
         if (idargs[46] === 1'b1 ||  idargs[10] === 1'b1) begin 
           measure_chain_out('d0);
         end
         if (idargs[43] === 1'b1 ||  idargs[9] === 1'b1) begin 
           LOD0=(LOAD[0] >> SSHIFTS) ^ CH_INPINV[0];
         end

           ->force_scells; 
         #0;
       end 
       begin: b2 
         assign_val('d`_clk , 4'bZ011);
         assign_stmt(the_wft_id);
       end 
     join 

     ->release_scells; 

         #0;
         if (sertmg == 1) begin
           v_count = v_count + PARSERINC - SSHIFTS - 1;
           for (i = 0; i < PARSERINC - SSHIFTS - 1; i = i+1) 
             complete_cycle(the_wft_id);
         end
         if (SSHIFTS > 0) shift_0(idargs, valargs, MAXCHLEN-SSHIFTS, 0) ; 

     end 
     else begin 
         shift_0(idargs, valargs, 0, 1);
     end
   end
   endtask


   always /* ParallelShiftMode */ @(force_scells) begin 
           force `CHAININ0 = LOD0;

   end


   always /* ParallelShiftMode */ @(release_scells) begin 
     release `CHAININ0; 
   end

   task load_unload ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     if (verbose >= 2) $display("XTB: Starting proc load_unload..., T=%0t, V=%0d", $time, v_count+1);

     if (xtb_sim_mode == 0 && ser_pats > 0 && cur_pat == (ser_pats+first_pat)) begin
       $display("XTB: Switching into Parallel simulation mode at pattern %0d (using %0d serial shifts)", cur_pat, SSHIFTS);
       xtb_sim_mode = 1; 
     end
     if (cur_pat != prev_pat) begin
       loads = 1;
       prev_pat = cur_pat;
       if (cur_pat % rep_pat == 0)
         $display("XTB: Begin %0s scan load for pattern %0d (T=%0t, V=%0d)", xtb_sim_mode?"parallel":"serial", cur_pat, $time, v_count+1);
     end
     else begin
       loads = loads + 1;
       if (cur_pat % rep_pat == 0)
         $display("XTB: Begin %0s scan load for pattern %0d, unload %0d (T=%0t, V=%0d)", xtb_sim_mode?"parallel":"serial", cur_pat, loads, $time, v_count+1);
     end
     save_context;
     resolve_wft(1);

     assign_val('d`all_inputs , 20'b0000000000X0XX1X1XXX);
     assign_val('d`all_outputs , 60'b111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     assign_val('d`TEST_SE , 2'b01);
     assign_stmt(the_wft_id);

     if (xtb_sim_mode)      p_shift_0(idargs, valargs);
     else      shift_0(idargs, valargs, 0, 1);

     restore_context;
   end 
   endtask

   task allclock_launch ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     if (verbose >= 2) $display("XTB: Starting proc allclock_launch..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_launch",47'b1, idargs);
     save_context;
     resolve_wft(2);

     assign_val('d`all_inputs , 20'b0000000000X0XX1X1XXX);
     assign_val('d`all_outputs , 60'b111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     assign_val('d`TEST_MODE , 2'b01);

     if (idargs[40] === 1'b1) assign_ival('d`_pi );
     if (idargs[1] === 1'b1) assign_ival('d`ALARM );
     if (idargs[5] === 1'b1) assign_ival('d`CLOCK );
     if (idargs[2] === 1'b1) assign_ival('d`HOURS );
     if (idargs[3] === 1'b1) assign_ival('d`MINUTES );
     if (idargs[6] === 1'b1) assign_ival('d`RESETN );
     if (idargs[0] === 1'b1) assign_ival('d`SET_TIME );
     if (idargs[7] === 1'b1) assign_ival('d`TEST_MODE );
     if (idargs[8] === 1'b1) assign_ival('d`TEST_SE );
     if (idargs[9] === 1'b1) assign_ival('d`TEST_SI );
     if (idargs[4] === 1'b1) assign_ival('d`TOGGLE );
     if (idargs[42] === 1'b1) assign_ival('d`_po );
     if (idargs[39] === 1'b1) assign_ival('d`AM_PM );
     if (idargs[24] === 1'b1) assign_ival('d`\HR[0]  );
     if (idargs[14] === 1'b1) assign_ival('d`\HR[10]  );
     if (idargs[13] === 1'b1) assign_ival('d`\HR[11]  );
     if (idargs[12] === 1'b1) assign_ival('d`\HR[12]  );
     if (idargs[11] === 1'b1) assign_ival('d`\HR[13]  );
     if (idargs[23] === 1'b1) assign_ival('d`\HR[1]  );
     if (idargs[22] === 1'b1) assign_ival('d`\HR[2]  );
     if (idargs[21] === 1'b1) assign_ival('d`\HR[3]  );
     if (idargs[20] === 1'b1) assign_ival('d`\HR[4]  );
     if (idargs[19] === 1'b1) assign_ival('d`\HR[5]  );
     if (idargs[18] === 1'b1) assign_ival('d`\HR[6]  );
     if (idargs[17] === 1'b1) assign_ival('d`\HR[7]  );
     if (idargs[16] === 1'b1) assign_ival('d`\HR[8]  );
     if (idargs[15] === 1'b1) assign_ival('d`\HR[9]  );
     if (idargs[38] === 1'b1) assign_ival('d`\MIN[0]  );
     if (idargs[28] === 1'b1) assign_ival('d`\MIN[10]  );
     if (idargs[27] === 1'b1) assign_ival('d`\MIN[11]  );
     if (idargs[26] === 1'b1) assign_ival('d`\MIN[12]  );
     if (idargs[25] === 1'b1) assign_ival('d`\MIN[13]  );
     if (idargs[37] === 1'b1) assign_ival('d`\MIN[1]  );
     if (idargs[36] === 1'b1) assign_ival('d`\MIN[2]  );
     if (idargs[35] === 1'b1) assign_ival('d`\MIN[3]  );
     if (idargs[34] === 1'b1) assign_ival('d`\MIN[4]  );
     if (idargs[33] === 1'b1) assign_ival('d`\MIN[5]  );
     if (idargs[32] === 1'b1) assign_ival('d`\MIN[6]  );
     if (idargs[31] === 1'b1) assign_ival('d`\MIN[7]  );
     if (idargs[30] === 1'b1) assign_ival('d`\MIN[8]  );
     if (idargs[29] === 1'b1) assign_ival('d`\MIN[9]  );
     if (idargs[10] === 1'b1) assign_ival('d`SPEAKER );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task allclock_capture ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     if (verbose >= 2) $display("XTB: Starting proc allclock_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_capture",47'b1, idargs);
     save_context;
     resolve_wft(3);

     assign_val('d`all_inputs , 20'b0000000000X0XX1X1XXX);
     assign_val('d`all_outputs , 60'b111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     assign_val('d`TEST_MODE , 2'b01);

     if (idargs[40] === 1'b1) assign_ival('d`_pi );
     if (idargs[1] === 1'b1) assign_ival('d`ALARM );
     if (idargs[5] === 1'b1) assign_ival('d`CLOCK );
     if (idargs[2] === 1'b1) assign_ival('d`HOURS );
     if (idargs[3] === 1'b1) assign_ival('d`MINUTES );
     if (idargs[6] === 1'b1) assign_ival('d`RESETN );
     if (idargs[0] === 1'b1) assign_ival('d`SET_TIME );
     if (idargs[7] === 1'b1) assign_ival('d`TEST_MODE );
     if (idargs[8] === 1'b1) assign_ival('d`TEST_SE );
     if (idargs[9] === 1'b1) assign_ival('d`TEST_SI );
     if (idargs[4] === 1'b1) assign_ival('d`TOGGLE );
     if (idargs[42] === 1'b1) assign_ival('d`_po );
     if (idargs[39] === 1'b1) assign_ival('d`AM_PM );
     if (idargs[24] === 1'b1) assign_ival('d`\HR[0]  );
     if (idargs[14] === 1'b1) assign_ival('d`\HR[10]  );
     if (idargs[13] === 1'b1) assign_ival('d`\HR[11]  );
     if (idargs[12] === 1'b1) assign_ival('d`\HR[12]  );
     if (idargs[11] === 1'b1) assign_ival('d`\HR[13]  );
     if (idargs[23] === 1'b1) assign_ival('d`\HR[1]  );
     if (idargs[22] === 1'b1) assign_ival('d`\HR[2]  );
     if (idargs[21] === 1'b1) assign_ival('d`\HR[3]  );
     if (idargs[20] === 1'b1) assign_ival('d`\HR[4]  );
     if (idargs[19] === 1'b1) assign_ival('d`\HR[5]  );
     if (idargs[18] === 1'b1) assign_ival('d`\HR[6]  );
     if (idargs[17] === 1'b1) assign_ival('d`\HR[7]  );
     if (idargs[16] === 1'b1) assign_ival('d`\HR[8]  );
     if (idargs[15] === 1'b1) assign_ival('d`\HR[9]  );
     if (idargs[38] === 1'b1) assign_ival('d`\MIN[0]  );
     if (idargs[28] === 1'b1) assign_ival('d`\MIN[10]  );
     if (idargs[27] === 1'b1) assign_ival('d`\MIN[11]  );
     if (idargs[26] === 1'b1) assign_ival('d`\MIN[12]  );
     if (idargs[25] === 1'b1) assign_ival('d`\MIN[13]  );
     if (idargs[37] === 1'b1) assign_ival('d`\MIN[1]  );
     if (idargs[36] === 1'b1) assign_ival('d`\MIN[2]  );
     if (idargs[35] === 1'b1) assign_ival('d`\MIN[3]  );
     if (idargs[34] === 1'b1) assign_ival('d`\MIN[4]  );
     if (idargs[33] === 1'b1) assign_ival('d`\MIN[5]  );
     if (idargs[32] === 1'b1) assign_ival('d`\MIN[6]  );
     if (idargs[31] === 1'b1) assign_ival('d`\MIN[7]  );
     if (idargs[30] === 1'b1) assign_ival('d`\MIN[8]  );
     if (idargs[29] === 1'b1) assign_ival('d`\MIN[9]  );
     if (idargs[10] === 1'b1) assign_ival('d`SPEAKER );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task multiclock_capture ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     if (verbose >= 2) $display("XTB: Starting proc multiclock_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("multiclock_capture",47'b1, idargs);
     save_context;
     resolve_wft(0);

     assign_val('d`all_inputs , 20'b0000000000X0XX1X1XXX);
     assign_val('d`all_outputs , 60'b111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     assign_val('d`TEST_MODE , 2'b01);

     if (idargs[40] === 1'b1) assign_ival('d`_pi );
     if (idargs[1] === 1'b1) assign_ival('d`ALARM );
     if (idargs[5] === 1'b1) assign_ival('d`CLOCK );
     if (idargs[2] === 1'b1) assign_ival('d`HOURS );
     if (idargs[3] === 1'b1) assign_ival('d`MINUTES );
     if (idargs[6] === 1'b1) assign_ival('d`RESETN );
     if (idargs[0] === 1'b1) assign_ival('d`SET_TIME );
     if (idargs[7] === 1'b1) assign_ival('d`TEST_MODE );
     if (idargs[8] === 1'b1) assign_ival('d`TEST_SE );
     if (idargs[9] === 1'b1) assign_ival('d`TEST_SI );
     if (idargs[4] === 1'b1) assign_ival('d`TOGGLE );
     if (idargs[42] === 1'b1) assign_ival('d`_po );
     if (idargs[39] === 1'b1) assign_ival('d`AM_PM );
     if (idargs[24] === 1'b1) assign_ival('d`\HR[0]  );
     if (idargs[14] === 1'b1) assign_ival('d`\HR[10]  );
     if (idargs[13] === 1'b1) assign_ival('d`\HR[11]  );
     if (idargs[12] === 1'b1) assign_ival('d`\HR[12]  );
     if (idargs[11] === 1'b1) assign_ival('d`\HR[13]  );
     if (idargs[23] === 1'b1) assign_ival('d`\HR[1]  );
     if (idargs[22] === 1'b1) assign_ival('d`\HR[2]  );
     if (idargs[21] === 1'b1) assign_ival('d`\HR[3]  );
     if (idargs[20] === 1'b1) assign_ival('d`\HR[4]  );
     if (idargs[19] === 1'b1) assign_ival('d`\HR[5]  );
     if (idargs[18] === 1'b1) assign_ival('d`\HR[6]  );
     if (idargs[17] === 1'b1) assign_ival('d`\HR[7]  );
     if (idargs[16] === 1'b1) assign_ival('d`\HR[8]  );
     if (idargs[15] === 1'b1) assign_ival('d`\HR[9]  );
     if (idargs[38] === 1'b1) assign_ival('d`\MIN[0]  );
     if (idargs[28] === 1'b1) assign_ival('d`\MIN[10]  );
     if (idargs[27] === 1'b1) assign_ival('d`\MIN[11]  );
     if (idargs[26] === 1'b1) assign_ival('d`\MIN[12]  );
     if (idargs[25] === 1'b1) assign_ival('d`\MIN[13]  );
     if (idargs[37] === 1'b1) assign_ival('d`\MIN[1]  );
     if (idargs[36] === 1'b1) assign_ival('d`\MIN[2]  );
     if (idargs[35] === 1'b1) assign_ival('d`\MIN[3]  );
     if (idargs[34] === 1'b1) assign_ival('d`\MIN[4]  );
     if (idargs[33] === 1'b1) assign_ival('d`\MIN[5]  );
     if (idargs[32] === 1'b1) assign_ival('d`\MIN[6]  );
     if (idargs[31] === 1'b1) assign_ival('d`\MIN[7]  );
     if (idargs[30] === 1'b1) assign_ival('d`\MIN[8]  );
     if (idargs[29] === 1'b1) assign_ival('d`\MIN[9]  );
     if (idargs[10] === 1'b1) assign_ival('d`SPEAKER );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task allclock_launch_capture ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     if (verbose >= 2) $display("XTB: Starting proc allclock_launch_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_launch_capture",47'b1, idargs);
     save_context;
     resolve_wft(4);

     assign_val('d`all_inputs , 20'b0000000000X0XX1X1XXX);
     assign_val('d`all_outputs , 60'b111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     assign_val('d`TEST_MODE , 2'b01);

     if (idargs[40] === 1'b1) assign_ival('d`_pi );
     if (idargs[1] === 1'b1) assign_ival('d`ALARM );
     if (idargs[5] === 1'b1) assign_ival('d`CLOCK );
     if (idargs[2] === 1'b1) assign_ival('d`HOURS );
     if (idargs[3] === 1'b1) assign_ival('d`MINUTES );
     if (idargs[6] === 1'b1) assign_ival('d`RESETN );
     if (idargs[0] === 1'b1) assign_ival('d`SET_TIME );
     if (idargs[7] === 1'b1) assign_ival('d`TEST_MODE );
     if (idargs[8] === 1'b1) assign_ival('d`TEST_SE );
     if (idargs[9] === 1'b1) assign_ival('d`TEST_SI );
     if (idargs[4] === 1'b1) assign_ival('d`TOGGLE );
     if (idargs[42] === 1'b1) assign_ival('d`_po );
     if (idargs[39] === 1'b1) assign_ival('d`AM_PM );
     if (idargs[24] === 1'b1) assign_ival('d`\HR[0]  );
     if (idargs[14] === 1'b1) assign_ival('d`\HR[10]  );
     if (idargs[13] === 1'b1) assign_ival('d`\HR[11]  );
     if (idargs[12] === 1'b1) assign_ival('d`\HR[12]  );
     if (idargs[11] === 1'b1) assign_ival('d`\HR[13]  );
     if (idargs[23] === 1'b1) assign_ival('d`\HR[1]  );
     if (idargs[22] === 1'b1) assign_ival('d`\HR[2]  );
     if (idargs[21] === 1'b1) assign_ival('d`\HR[3]  );
     if (idargs[20] === 1'b1) assign_ival('d`\HR[4]  );
     if (idargs[19] === 1'b1) assign_ival('d`\HR[5]  );
     if (idargs[18] === 1'b1) assign_ival('d`\HR[6]  );
     if (idargs[17] === 1'b1) assign_ival('d`\HR[7]  );
     if (idargs[16] === 1'b1) assign_ival('d`\HR[8]  );
     if (idargs[15] === 1'b1) assign_ival('d`\HR[9]  );
     if (idargs[38] === 1'b1) assign_ival('d`\MIN[0]  );
     if (idargs[28] === 1'b1) assign_ival('d`\MIN[10]  );
     if (idargs[27] === 1'b1) assign_ival('d`\MIN[11]  );
     if (idargs[26] === 1'b1) assign_ival('d`\MIN[12]  );
     if (idargs[25] === 1'b1) assign_ival('d`\MIN[13]  );
     if (idargs[37] === 1'b1) assign_ival('d`\MIN[1]  );
     if (idargs[36] === 1'b1) assign_ival('d`\MIN[2]  );
     if (idargs[35] === 1'b1) assign_ival('d`\MIN[3]  );
     if (idargs[34] === 1'b1) assign_ival('d`\MIN[4]  );
     if (idargs[33] === 1'b1) assign_ival('d`\MIN[5]  );
     if (idargs[32] === 1'b1) assign_ival('d`\MIN[6]  );
     if (idargs[31] === 1'b1) assign_ival('d`\MIN[7]  );
     if (idargs[30] === 1'b1) assign_ival('d`\MIN[8]  );
     if (idargs[29] === 1'b1) assign_ival('d`\MIN[9]  );
     if (idargs[10] === 1'b1) assign_ival('d`SPEAKER );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask


   always @(start_part) begin: _burst__pattern__proc_unit

     integer nbpats, i;
     reg [5:0] nargs, na;
     reg [5:0] args;

     integer tdf;
     nbpats = 0; cur_pat = -1;
     end_pat = 0; v_count = 0; v_count_per_pat = 0;
     nbfails = 0;
     prev_pat = -2; prev_error = -2; first_pat = 0;
     diagf = 0;
     read_data;
     data_i = 1; 
     popcode = 'd0;

     if (diagm > 0) begin
       if (diagm > 2) begin
         $display("XTB Warning: wrong diagnosis mode (%0d), using default mode 1 (pattern based)", diagm);
         diagm = 1 ; 
       end  
       `ifdef tmax_diag_file 
         diag_file = `tmax_diag_file;
       `else 
         diag_file = "testbench.diag"; 
       `endif
       diagf = $fopen(diag_file);
       if (diagf == 0) begin
         $display("XTB Error: Unable to open diagnosis file %s (for writing). Exiting...", diag_file);
         $finish; 
       end
       if (verbose >= 1) $display("XTB: User requesting TetraMAX compliant diagnosis file: %0s", diag_file);
       $fdisplay(diagf, "// Serial scan error:       <pat#> \t<pin_name> \t<shift_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// USF Parallel scan error: <pat#> \t<pin_name> \t<shift_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// DSF Parallel scan error: <pat#> \t<chain_name> \t<cell_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// Capture error:           <pat#> \t<pin_name> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// Cycle based error:          C \t<pin_name> \t<vect_nbr> \t(<expected_value> <simulated_value>)\n\n");

     end 

     memel = memall[data_i]; 
     total_pats = memel[31:0];
     data_i=data_i+1;

     last_pat = -1;

     if (total_pats < 0 || |(total_pats) === 1'bx) begin
       $display("XTB Error: Inconsistent total number of patterns (%d). Exiting...",  total_pats);
       $finish;
     end

     if (verbose >= 1) $display("XTB: Total number of patterns  %0d",  total_pats); 
     if (last_pat == -1) last_pat = total_pats - 1;

     `ifdef tmax_n_pattern_sim
     last_pat=`tmax_n_pattern_sim;
     `endif

     `ifdef tmax_test_setup_only_once
     test_setup_only_once = 1;
     `endif

     xtb_sim_mode = 1;
     SSHIFTS = DFSHIFTS;

     ser_pats = 0;
     csim_op = -1;

     `ifdef tmax_serial
       if (~(`tmax_serial & 1'b1) == 1'b0) 
         ser_pats = last_pat + 1;
       else 
         ser_pats = `tmax_serial + 0;
       if (ser_pats > 0)
       csim_op = 0;
       `ifdef tmax_parallel 
         SSHIFTS = `tmax_parallel + 0; 
         if (ser_pats  >= last_pat + 1) begin	 
           csim_op = 2; 
         end 
         else if (ser_pats == 0)
           csim_op = 1;
       `endif
     `else 
       `ifdef tmax_parallel
         csim_op = 1;
         SSHIFTS = `tmax_parallel + 0; 
       `endif 
     `endif
     if (SSHIFTS < 0) begin
       $display("XTB Error: Passing negative value (%0d) of serial shifts in parallel mode. Exiting...",  SSHIFTS);
       $finish; 
     end

     process_rtops;
     `ifdef tmax_serial_timing 
       sertmg = 1;
       if (xtb_sim_mode == 1) $display("XTB: Parallel simulation (timing and vector) extended to match serial simulation");
     `else 
       sertmg = 0; 
     `endif


     $display("XTB: Starting %0s simulation of %0d pattern%s", xtb_sim_mode == 0 ? "serial" : "parallel", xtb_sim_mode == 0 ? ((ser_pats>last_pat || ser_pats==0)?(last_pat+1):ser_pats): last_pat + 1, (xtb_sim_mode!=0 || ser_pats>1)?"s":"");
     if (xtb_sim_mode) begin 
       $display("XTB: Using %0d serial shifts", SSHIFTS);
     end

     if (SSHIFTS >= MAXCHLEN)  begin 
       $display("XTB Warning: serial shifts (%0d) equals or exceeds max chain length (%0d). Performing full serial scan... ", SSHIFTS, MAXCHLEN); 
       xtb_sim_mode = 0;	
     end 

     if (diagm==2 && xtb_sim_mode==1)  begin 
       $display("XTB Warning: cannot display cycle-based diagnostic messages in parallel load mode simulation. Simulation will display pattern-based diagnostic messages."); 
       diagm = 1;	
     end 

     while (cur_pat <= last_pat && end_pat != 1) begin 
       memel = memall[data_i];
       opcode = memel[4:0];
       cur_stmt = -1;
       args = 'b0;
       case (opcode)
         'd`EndPat:  begin
                       cur_stmt = `EndPat;
                       end_pat = 1;
                     end
         'd`IncPat:  begin
                       cur_stmt = `IncPat;
                       cur_pat = cur_pat + 1;
                       v_count_per_pat = 0;
                       nbpats = nbpats+1;

                     end
         'd`SetForceSI:  begin
                       cur_stmt = `SetForceSI;
                     end
         'd`SetPat:  begin
                       cur_stmt = `SetPat;
                       if (cur_pat==-1) begin first_pat = memel[32:5]; cur_pat = first_pat; end
                       else cur_pat = memel[32:5];
                       v_count_per_pat = 0;
                       last_pat = last_pat + cur_pat; 
                       nbpats = nbpats+1;  
                     end
         'd`WFTStmt: begin
                       cur_stmt = `WFTStmt;
                       resolve_wft(memel[7:5]);
                     end 
         'd`ConditionStmt, 'd`FixedStmt, 'd`VectorStmt: begin
           if (opcode == 'd`ConditionStmt) cur_stmt = 'd`ConditionStmt;
           else 	cur_stmt='d`VectorStmt;
           nargs = memel[10:5];
           na = 0;
           while (na<nargs) begin
             data_i = data_i + 1;
             memel = memall[data_i];
             assign_val(memel[SIG_IDS_W-1:0], memel[2*MAX_WIDTH+SIG_IDS_W-1:SIG_IDS_W]);
             na = na + 1;
           end
           if (opcode == `VectorStmt) assign_stmt(the_wft_id);
          end 
          'd`GenLoopStmt: begin: GenLoop_BLOCK
            cur_stmt = `GenLoopStmt;
            lp_count = 1;
            lp_addr = data_i;
            lp_max = memel[10:5];
            $display("\nXTB: starting loop statement with %0d iterations", lp_max); 
          end 
          'd`EndGenLoopStmt: begin: EndLoop_BLOCK
            cur_stmt = `EndGenLoopStmt;
            $display("\nXTB: loop iteration %0d/%0d done.", lp_count, lp_max);
            lp_count = lp_count+1;
            if (lp_count <= lp_max) begin
              data_i = lp_addr;
            end 
         end 
         'd`test_setupStmt: begin: test_setup_BLOCK
           cur_stmt = `test_setupStmt;
           set_args(memel[10:5]);
           test_setup(sid_args, sval_args);
         end 
         'd`load_unloadStmt: begin: load_unload_BLOCK
           cur_stmt = `load_unloadStmt;
            na = 0; nargs = 'b0; sid_args = 'b0; sval_args = 'b0;
            nargs = memel[10:5];
            while (na < nargs) begin
              data_i = data_i + 1;
              memel = memall[data_i];
              if (memel[SIG_IDS_W-1:0] > SIG_IDS-1) begin
                $display("\nXTB Error: Passing wrong signal ID (%b), valid range is 1..%d. Exiting...", memel[SIG_IDS_W-1:0], SIG_IDS-1);
                $finish;
              end
              sid_args[memel[SIG_IDS_W-1:0]] = 1'b1;
              case (memel[SIG_IDS_W-1:0])
               'd`_si , 'd`TEST_SI: begin LOAD[0] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`_so , 'd`SPEAKER: begin UNLOAD[0] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               default: begin  
                 $display("\nXTB Error: Wrong signal argument (%s) passed to load_unload procedure. Exiting...", SignalIDName[memel[SIG_IDS_W-1:0]]);
                 $finish; 
               end 
             endcase 
             na = na+1;
           end
           load_unload(sid_args, sval_args);
         end 
         'd`allclock_launchStmt: begin: allclock_launch_BLOCK
           cur_stmt = `allclock_launchStmt;
           set_args(memel[10:5]);
           allclock_launch(sid_args, sval_args);
         end 
         'd`allclock_captureStmt: begin: allclock_capture_BLOCK
           cur_stmt = `allclock_captureStmt;
           set_args(memel[10:5]);
           allclock_capture(sid_args, sval_args);
         end 
         'd`multiclock_captureStmt: begin: multiclock_capture_BLOCK
           cur_stmt = `multiclock_captureStmt;
           set_args(memel[10:5]);
           multiclock_capture(sid_args, sval_args);
         end 
         'd`allclock_launch_captureStmt: begin: allclock_launch_capture_BLOCK
           cur_stmt = `allclock_launch_captureStmt;
           set_args(memel[10:5]);
           allclock_launch_capture(sid_args, sval_args);
         end 
         default: begin $display("\nXTB Error: Unrecognized code %0h, @ inst %0d", opcode, data_i); $finish; end 
       endcase 
       data_i = data_i + 1;
       popcode = opcode;
       if (verbose >= 3) display_stmt(cur_stmt);
     end 
     $display("XTB: Simulation of %0d pattern%s completed with %0d mismatch%s (time: %0t, cycles: %0d)\n", nbpats+end_pat-1, (nbpats==1)?"":"s", nbfails, (nbfails==1)?"":"es", $time, v_count); 

     if (diagf) $fclose(diagf);
     ->end_part;
   end 


   task init_rtops;
     integer i;
   begin
     for (i=0; i<`NBRTOPS; i=i+1)
       rt_ops[i] = -1;
     RT_OPS [0] = "tmax_n_pattern_sim"; RT_OPS [1] = "tmax_serial"; RT_OPS [2] = "tmax_parallel"; RT_OPS [3] = "tmax_msg"; RT_OPS [4] = "tmax_rpt"; RT_OPS [5] = "tmax_test_setup_only_once"; RT_OPS [6] = "tmax_usf_debug_strobe_mode"; 
   end 
   endtask

   task process_rtops;
     integer sim_op, p_mode;
     integer i;
   begin
     sim_op = -1;
     init_rtops;
     for (i=0; i<`NBRTOPS; i=i+1)
       $value$plusargs ({RT_OPS[i], "=%d"}, rt_ops[i]);
     if ((rt_ops[0] > -1))   last_pat =  rt_ops[0];
     if (last_pat != total_pats-1) begin
       display_ops ((rt_ops[0] > 0), last_pat, RT_OPS[0]);
       $display("XTB: User requesting simulating patterns 0 to %0d",last_pat);
     end 
     if (last_pat >= total_pats && total_pats > 1) begin
       $display("XTB Error: Simulation patterns (%0d) exceeds total pattern count (%0d). Exiting...",  last_pat+1,total_pats);
       $finish;
     end 
     else if (last_pat < 0 && total_pats != 0)  begin 
       $display("XTB Error: User requesting simulating wrong number of patterns (%0d). Exiting... ",last_pat+1);
       $finish;
     end
     if (rt_ops[5] != 0 && ($test$plusargs ("tmax_test_setup_only_once"))) begin
       test_setup_only_once = 1;
       rt_ops[5] = 1;
     end
     if ((rt_ops[1] > 0)) begin
       if (rt_ops[1]==0) ser_pats = last_pat + 1;
       else ser_pats = rt_ops[1];
       sim_op = 0;
     end 
     else if (rt_ops[1] != 0 &&  ($test$plusargs ("tmax_serial"))) begin
       ser_pats = last_pat + 1;
       rt_ops[1] = ser_pats;
       sim_op = 0;
     end
     if ((rt_ops[1]>0) || (csim_op==0 || csim_op==2)) display_ops ((rt_ops[1]>0), ser_pats, RT_OPS[1]);
     p_mode = ((rt_ops[2] > -1) || ($test$plusargs ("tmax_parallel")))?1:0;
     if (p_mode) begin
       SSHIFTS = (rt_ops[2] > -1)?rt_ops[2]:0;
       if (sim_op == -1)
         sim_op = 1;
       else  if (ser_pats  < last_pat + 1)
         sim_op = 0;
       else 
         sim_op = 2;
     end 
     if (p_mode || (csim_op==1 || csim_op==2)) display_ops (p_mode, SSHIFTS, RT_OPS[2]);
     if (sim_op > -1)
       set_sim_ops (sim_op);
     else if (csim_op > -1)
       set_sim_ops (csim_op);
     if (rt_ops[3] > -1) begin
       verbose = rt_ops[3];
     end
     if (verbose != 0) 
       display_ops ((rt_ops[3]>-1), verbose, RT_OPS[3]);
     if (rt_ops[4] > -1) begin
       rep_pat =  rt_ops[4];
     end
     if (rep_pat != 5) 
       display_ops ((rt_ops[4]>-1), rep_pat, RT_OPS[4]);
      if (test_setup_only_once > 0) begin
        display_ops ((rt_ops[5]>-1), test_setup_only_once, RT_OPS[5]);
      end
   end 
   endtask

   task display_ops;
     input reg rt;
     input integer val;
     input reg [32*8:1] opname;
   begin
     $display("XTB: Setting %0s option \"%0s\" to %0d.", (rt==1)?"runtime":"compile-time",  opname, val);
   end 
   endtask

   task display_help;
   integer op;
   begin
     init_rtops;
     $display("\n\n\t\t----------------------- Runtime Help ------------------------------\n");
     $display("XTB: Usage is: <sim_exec> +opt1=val1 +opt2=val2...");
     $display("     where  <sim_exec> is the simulation exec name, and opt1 opt2 are available options and val1, val2 their corresponding values.");
     $display("     Available runtime options are:");
     op = 0;
     while (op < `NBRTOPS) begin
       $display("        +%0s", RT_OPS[op]);
       op = op + 1;
     end
     $display("\n      E.g.: simv +tmax_serial=2 +tmax_msg=2, runs first 2 patterns in serial and remaining in parallel, and set the verbose msg level to 2.");
     $display("\n Note: Runtime options override corresponding compile-time options.");
     $display("\n       Please refer to the User's Guide for details regarding each option.");
     $display("\n\t\t-------------------------------------------------------------------\n");
   end 
   endtask

   task set_sim_ops;
     input integer smode;
   begin
     if (smode==0) begin 
       xtb_sim_mode = 0;
       $write("XTB: Enabling serial simulation for");
       if (ser_pats < last_pat + 1) begin
         if (ser_pats==1) $write(" the first pattern.\n");
         else $write(" first %0d patterns.\n", ser_pats);
       end else 
         $write(" all patterns.\n");
     end
     else if (smode==1) begin 
       $write("XTB: Enabling parallel simulation with %0d serial shift(s).\n", SSHIFTS);
       xtb_sim_mode = 1;
     end 
     else  if (smode==2) begin
       $display("XTB Warning: requesting full serial simulation and full parallel simulation in the same time. Performing default parallel simulation mode...");
       xtb_sim_mode = 1;
     end 
   end 
   endtask


   initial begin: _burst__pattern__init_unit

     `ifdef tmax_fsdb
       $fsdbDumpvars;
     `endif


     for (n=0; n<SIG_IDS; n=n+1) SignalIDWidth[n] = 0;
     SignalIDName[0] = "SET_TIME";
     SignalIDType[0] = 0; //SET_TIME
     SignalIDWidth[0] = 1; //SET_TIME
     SignalIDName[1] = "ALARM";
     SignalIDType[1] = 0; //ALARM
     SignalIDWidth[1] = 1; //ALARM
     SignalIDName[2] = "HOURS";
     SignalIDType[2] = 0; //HOURS
     SignalIDWidth[2] = 1; //HOURS
     SignalIDName[3] = "MINUTES";
     SignalIDType[3] = 0; //MINUTES
     SignalIDWidth[3] = 1; //MINUTES
     SignalIDName[4] = "TOGGLE";
     SignalIDType[4] = 0; //TOGGLE
     SignalIDWidth[4] = 1; //TOGGLE
     SignalIDName[5] = "CLOCK";
     SignalIDType[5] = 0; //CLOCK
     SignalIDWidth[5] = 1; //CLOCK
     SignalIDName[6] = "RESETN";
     SignalIDType[6] = 0; //RESETN
     SignalIDWidth[6] = 1; //RESETN
     SignalIDName[7] = "TEST_MODE";
     SignalIDType[7] = 0; //TEST_MODE
     SignalIDWidth[7] = 1; //TEST_MODE
     SignalIDName[8] = "TEST_SE";
     SignalIDType[8] = 0; //TEST_SE
     SignalIDWidth[8] = 1; //TEST_SE
     SignalIDName[9] = "TEST_SI";
     SignalIDType[9] = 0; //TEST_SI
     SignalIDWidth[9] = 1; //TEST_SI
     SignalIDName[10] = "SPEAKER";
     SignalIDType[10] = 1; //SPEAKER
     SignalIDWidth[10] = 1; //SPEAKER
     SignalIDName[11] = "\HR[13] ";
     SignalIDType[11] = 1; //\HR[13] 
     SignalIDWidth[11] = 1; //\HR[13] 
     SignalIDName[12] = "\HR[12] ";
     SignalIDType[12] = 1; //\HR[12] 
     SignalIDWidth[12] = 1; //\HR[12] 
     SignalIDName[13] = "\HR[11] ";
     SignalIDType[13] = 1; //\HR[11] 
     SignalIDWidth[13] = 1; //\HR[11] 
     SignalIDName[14] = "\HR[10] ";
     SignalIDType[14] = 1; //\HR[10] 
     SignalIDWidth[14] = 1; //\HR[10] 
     SignalIDName[15] = "\HR[9] ";
     SignalIDType[15] = 1; //\HR[9] 
     SignalIDWidth[15] = 1; //\HR[9] 
     SignalIDName[16] = "\HR[8] ";
     SignalIDType[16] = 1; //\HR[8] 
     SignalIDWidth[16] = 1; //\HR[8] 
     SignalIDName[17] = "\HR[7] ";
     SignalIDType[17] = 1; //\HR[7] 
     SignalIDWidth[17] = 1; //\HR[7] 
     SignalIDName[18] = "\HR[6] ";
     SignalIDType[18] = 1; //\HR[6] 
     SignalIDWidth[18] = 1; //\HR[6] 
     SignalIDName[19] = "\HR[5] ";
     SignalIDType[19] = 1; //\HR[5] 
     SignalIDWidth[19] = 1; //\HR[5] 
     SignalIDName[20] = "\HR[4] ";
     SignalIDType[20] = 1; //\HR[4] 
     SignalIDWidth[20] = 1; //\HR[4] 
     SignalIDName[21] = "\HR[3] ";
     SignalIDType[21] = 1; //\HR[3] 
     SignalIDWidth[21] = 1; //\HR[3] 
     SignalIDName[22] = "\HR[2] ";
     SignalIDType[22] = 1; //\HR[2] 
     SignalIDWidth[22] = 1; //\HR[2] 
     SignalIDName[23] = "\HR[1] ";
     SignalIDType[23] = 1; //\HR[1] 
     SignalIDWidth[23] = 1; //\HR[1] 
     SignalIDName[24] = "\HR[0] ";
     SignalIDType[24] = 1; //\HR[0] 
     SignalIDWidth[24] = 1; //\HR[0] 
     SignalIDName[25] = "\MIN[13] ";
     SignalIDType[25] = 1; //\MIN[13] 
     SignalIDWidth[25] = 1; //\MIN[13] 
     SignalIDName[26] = "\MIN[12] ";
     SignalIDType[26] = 1; //\MIN[12] 
     SignalIDWidth[26] = 1; //\MIN[12] 
     SignalIDName[27] = "\MIN[11] ";
     SignalIDType[27] = 1; //\MIN[11] 
     SignalIDWidth[27] = 1; //\MIN[11] 
     SignalIDName[28] = "\MIN[10] ";
     SignalIDType[28] = 1; //\MIN[10] 
     SignalIDWidth[28] = 1; //\MIN[10] 
     SignalIDName[29] = "\MIN[9] ";
     SignalIDType[29] = 1; //\MIN[9] 
     SignalIDWidth[29] = 1; //\MIN[9] 
     SignalIDName[30] = "\MIN[8] ";
     SignalIDType[30] = 1; //\MIN[8] 
     SignalIDWidth[30] = 1; //\MIN[8] 
     SignalIDName[31] = "\MIN[7] ";
     SignalIDType[31] = 1; //\MIN[7] 
     SignalIDWidth[31] = 1; //\MIN[7] 
     SignalIDName[32] = "\MIN[6] ";
     SignalIDType[32] = 1; //\MIN[6] 
     SignalIDWidth[32] = 1; //\MIN[6] 
     SignalIDName[33] = "\MIN[5] ";
     SignalIDType[33] = 1; //\MIN[5] 
     SignalIDWidth[33] = 1; //\MIN[5] 
     SignalIDName[34] = "\MIN[4] ";
     SignalIDType[34] = 1; //\MIN[4] 
     SignalIDWidth[34] = 1; //\MIN[4] 
     SignalIDName[35] = "\MIN[3] ";
     SignalIDType[35] = 1; //\MIN[3] 
     SignalIDWidth[35] = 1; //\MIN[3] 
     SignalIDName[36] = "\MIN[2] ";
     SignalIDType[36] = 1; //\MIN[2] 
     SignalIDWidth[36] = 1; //\MIN[2] 
     SignalIDName[37] = "\MIN[1] ";
     SignalIDType[37] = 1; //\MIN[1] 
     SignalIDWidth[37] = 1; //\MIN[1] 
     SignalIDName[38] = "\MIN[0] ";
     SignalIDType[38] = 1; //\MIN[0] 
     SignalIDWidth[38] = 1; //\MIN[0] 
     SignalIDName[39] = "AM_PM";
     SignalIDType[39] = 1; //AM_PM
     SignalIDWidth[39] = 1; //AM_PM
     SignalIDName[40] = "_pi";
     SignalIDType[40] = 3; //_pi
     SignalIDWidth[40] = 10; //_pi
     SignalIDName[41] = "all_inputs";
     SignalIDType[41] = 3; //all_inputs
     SignalIDWidth[41] = 10; //all_inputs
     SignalIDName[42] = "_po";
     SignalIDType[42] = 3; //_po
     SignalIDWidth[42] = 30; //_po
     SignalIDName[43] = "_si";
     SignalIDType[43] = 3; //_si
     SignalIDWidth[43] = 1; //_si
     SignalIDName[44] = "all_outputs";
     SignalIDType[44] = 3; //all_outputs
     SignalIDWidth[44] = 30; //all_outputs
     SignalIDName[45] = "_clk";
     SignalIDType[45] = 3; //_clk
     SignalIDWidth[45] = 2; //_clk
     SignalIDName[46] = "_so";
     SignalIDType[46] = 3; //_so
     SignalIDWidth[46] = 1; //_so
     WFTIDName[0] = "_multiclock_capture_WFT_";
     WFTIDName[1] = "_default_WFT_";
     WFTIDName[2] = "_allclock_launch_WFT_";
     WFTIDName[3] = "_allclock_capture_WFT_";
     WFTIDName[4] = "_allclock_launch_capture_WFT_";
     StmtNames[0] = "EndPat";
     StmtNames[1] = "IncPat";
     StmtNames[2] = "SetPat";
     StmtNames[3] = "WFTStmt";
     StmtNames[4] = "ConditionStmt";
     StmtNames[5] = "VectorStmt";
     StmtNames[6] = "FixedStmt";
     StmtNames[7] = "GenLoopStmt";
     StmtNames[8] = "EndGenLoopStmt";
     StmtNames[9] = "GenTestSetupStmt";
     StmtNames[10] = "EndGenTestSetupStmt";
     StmtNames[11] = "SetForceSI";
     StmtNames[12] = "test_setupStmt";
     StmtNames[13] = "load_unloadStmt";
     StmtNames[14] = "allclock_launchStmt";
     StmtNames[15] = "allclock_captureStmt";
     StmtNames[16] = "multiclock_captureStmt";
     StmtNames[17] = "allclock_launch_captureStmt";

     $display("%s",`MAXTB_H_S);
     $display("%s",`MAXTB_HEADER);
     $display("%s\n",`MAXTB_H_S);

     if ( $test$plusargs ("tmax_help") ) begin
       display_help;
       $finish(0);
     end

     $timeformat(-9,2," ns",19);

     `ifdef tmax_test_data_file 
       tdfm = 1;
       TDATA_FILE = `tmax_test_data_file ;
     `else
       tdfm = 0;
       TDATA_FILE = `TDATA_FILE ;
     `endif


     `ifdef tmax_vcde
       $display("XTB: Dumping Extended VCD information in file \"testbench.vcd\"");
       $dumpports( dut, "testbench.vcd");
     `endif

     `ifdef tmax_msg
       verbose = `tmax_msg ;
     `else
       verbose = 0 ;
     `endif

     `ifdef tmax_debug
     if (~(`tmax_debug & 1'b1) == 1'b0)
       debug = 1;
     else
       debug = `tmax_debug + 0 ;
     `else
     debug = 0 ;
     `endif

     `ifdef tmax_rpt
     rep_pat = `tmax_rpt ;
     `else
     rep_pat = 5 ;
     `endif

     test_setup_runs = 0;

     CH_NAMES[0] = "1";
     CH_PINS[0] = "SPEAKER";
     CH_OUTINV[0] = 40'b0000101101110101010101001011101011101010;
     CH_INPINV[0] = 40'b1110100100010101010101101000101000101010;

     diagm = 0;
     diag_file = "";

     `ifdef tmax_diag 
       diagm = `tmax_diag;
     `endif

     -> start_part;
     @(end_part) #0;
     $finish(0);

   end

 endmodule
